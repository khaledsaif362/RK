<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dot Line Puzzle</title>
  <style>
    body { background:#222; color:#fff; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; margin:0;}
    #board { display:grid; grid-template-columns:repeat(6,50px); grid-template-rows:repeat(6,50px); gap:6px; margin:20px 0;}
    .cell { width:48px; height:48px; background:#111; border-radius:8px; display:flex; align-items:center; justify-content:center; position:relative;}
    .dot { width:34px; height:34px; border-radius:50%; display:block; margin:auto;}
    #level { margin:10px; }
    #nextbtn { padding:10px 20px; font-weight:bold; display:none; margin-bottom:10px;}
    #resetbtn { padding:6px 12px; margin-bottom:10px;}
    canvas { position:absolute; top:0; left:0;}
  </style>
</head>
<body>
  <h2 id="level">Level 1</h2>
  <button id="nextbtn" onclick="nextLevel()">Next Level</button>
  <button id="resetbtn" onclick="drawBoard()">Reset Level</button>
  <div id="board"></div>
  <script>
    // Define 40 sample levels (feel free to adjust or add more)
    // Use: 0 = empty, 1-6 = color index, must appear in pairs
    const levels = [
      [
        [1,0,0,0,0,2],
        [0,0,0,0,0,0],
        [0,0,2,0,0,0],
        [0,0,0,0,0,0],
        [0,0,0,0,1,0],
        [0,0,0,0,0,0],
      ],
      [
        [1,0,0,0,2,0],
        [0,0,0,0,0,0],
        [0,0,3,0,0,0],
        [0,2,0,0,0,0],
        [0,0,0,3,0,1],
        [0,0,0,0,0,0],
      ],
      // ... add up to 40 levels, here's a pattern, repeat/modify as needed:
      [
        [1,0,0,2,0,3],
        [0,0,4,0,0,0],
        [2,0,4,0,0,0],
        [1,0,0,0,0,0],
        [0,0,0,0,0,3],
        [0,0,0,0,0,0],
      ],
      [
        [1,0,0,0,0,2],
        [0,3,0,4,0,0],
        [0,0,4,0,0,0],
        [2,0,0,0,3,0],
        [0,0,0,1,0,0],
        [0,0,0,0,0,0],
      ],
      // Duplicate, shuffle, or expand this style up to 40 levels!
    ];

    // Expand placeholder levels to 40 for demonstration
    while (levels.length < 40) {
      let temp = JSON.parse(JSON.stringify(levels[levels.length % 4]));
      // Rotate or mutate dots for variety
      for (let i=0; i<6; i++) temp[i] = temp[i].slice().reverse();
      levels.push(temp);
    }

    const colors = ["#f00", "#0f0", "#00f", "#ff0", "#0ff", "#f0f"];
    let curLevel = 0;
    let paths = [], started=null, drawingPath=[];
    const board = document.getElementById('board');
    const levelH = document.getElementById('level');
    const nextbtn = document.getElementById('nextbtn');
    let canvas, ctx;

    function drawBoard() {
      board.innerHTML = '';
      paths = []; drawingPath = []; started = null; nextbtn.style.display = 'none';

      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = 300; canvas.height = 300;
        canvas.style.pointerEvents = 'none';
        canvas.style.position = 'absolute';
        canvas.style.top = '0'; canvas.style.left = '0';
        ctx = canvas.getContext('2d');
        board.appendChild(canvas);
      }
      board.appendChild(canvas); // makes sure on top
      for (let r=0;r<6;r++) for (let c=0;c<6;c++) {
        let d = levels[curLevel][r][c];
        let div = document.createElement('div');
        div.className = 'cell';
        div.dataset.row = r; div.dataset.col = c;
        if (d>0) {
          let dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = colors[d-1];
          div.appendChild(dot);
        }
        div.onmousedown = div.ontouchstart = e => handleStart(e, r, c);
        div.onmouseenter = div.ontouchmove = e => handleMove(e, r, c);
        div.onmouseup = div.ontouchend = handleEnd;
        board.appendChild(div);
      }
      // Redraw lines
      setTimeout(drawLines, 10);
    }

    function handleStart(e,r,c) {
      let d = levels[curLevel][r][c];
      if (d > 0 && !paths.some(p => p[0]==r && p[1]==c))
        { started = {color:d, path:[[r,c]]}; drawingPath = [[r,c]];}
    }

    function handleMove(e,r,c) {
      if (started) {
        let last = drawingPath[drawingPath.length-1];
        // Only allow adjacent and not cross itself
        if (Math.abs(last-r)+Math.abs(last[1]-c)==1 && !drawingPath.some(pt => pt==r && pt[1]==c)) {
          drawingPath.push([r,c]);
          drawLines();
          // If matches end dot
          if (levels[curLevel][r][c]==started.color && drawingPath.length>1) {
              // Check end
              paths.push(drawingPath.slice());
              started = null; drawingPath=[];
              checkComplete();
          }
        }
      }
    }
    function handleEnd(e){
      started = null; drawingPath=[];
      drawLines();
    }

    function drawLines() {
      ctx.clearRect(0,0,300,300);
      paths.forEach((path,i)=>{
        ctx.strokeStyle = colors[levels[curLevel][path][path[1]]-1];
        ctx.lineWidth = 10;
        ctx.beginPath();
        path.forEach(([r,c],i)=>{
          let x = c*50+25, y = r*50+25;
          i ? ctx.lineTo(x,y): ctx.moveTo(x,y);
        });
        ctx.stroke();
      });
      if (drawingPath.length>1) {
        ctx.strokeStyle = colors[started.color-1];
        ctx.lineWidth = 6;
        ctx.beginPath();
        drawingPath.forEach(([r,c],i)=>{
          let x = c*50+25, y = r*50+25;
          i ? ctx.lineTo(x,y): ctx.moveTo(x,y);
        });
        ctx.stroke();
      }
    }

    function checkComplete() {
      let filled = Array.from({length:6},()=>Array(6).fill(0));
      paths.forEach(path=>path.forEach(([r,c])=>filled[r][c]=1));
      // All pairs must be connected and board filled by lines or dots
      let allDotsConnected = true, allFilled = true;
      for (let r=0;r<6;r++) for (let c=0;c<6;c++) {
        if (levels[curLevel][r][c]>0) {
          const dot = [r,c], color = levels[curLevel][r][c];
          if (!paths.some(p => (p[0]==r && p[1]==c)||(p[p.length-1]==r && p[p.length-1][1]==c))) {
            allDotsConnected = false;
          }
        }
        if (levels[curLevel][r][c]==0 && !filled[r][c]) allFilled = false;
      }
      if (allDotsConnected && allFilled) {
        nextbtn.style.display = 'inline-block';
      }
    }

    function nextLevel() {
      curLevel = (curLevel+1)%levels.length;
      levelH.textContent = 'Level '+(curLevel+1);
      drawBoard();
    }

    levelH.textContent = 'Level 1';
    drawBoard();
  </script>
</body>
</html>
